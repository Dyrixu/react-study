# 生命周期

## 类组件生命周期介绍

__React 有两个重要阶段，render 阶段和 commit 阶段__

React 在调和（render）阶段会深度遍历 React fiber 树，目的就是发现不同（diff），不同的地方就是接下来需要更新的地方，，对于组件的变化，就会执行 render 函数。
在一次调和过程完毕之后，就到了 commit 阶段，commit 阶段会创建修改真实 Dom

```
/* workloop React 处理类组件的主要功能方法 */
function updateClassComponent(){
    let shouldUpdate
    const instance = workInProgress.stateNode // stateNode 是 fiber 指向 类组件实例的指针。
     if (instance === null) { // instance 为组件实例,如果组件实例不存在，证明该类组件没有被挂载过，那么会走初始化流程
        constructClassInstance(workInProgress, Component, nextProps); // 组件实例将在这个方法中被new。在初始化的时候构建实例
        mountClassInstance(  workInProgress,Component, nextProps,renderExpirationTime ); //初始化挂载组件流程
        shouldUpdate = true; // shouldUpdate 标识用来证明 组件是否需要更新。
     }else{  
        shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderExpirationTime) // 更新组件流程
     }
     if(shouldUpdate){
         nextChildren = instance.render(); /* 执行render函数 ，得到子节点 */
        reconcileChildren(current,workInProgress,nextChildren,renderExpirationTime) /* 继续调和子节点 */
     }
}
```

__几个重要概念__

* __instance__ 类组件对应实例
* __workInProgress__ 树，当前正在调和的 fiber 树，一次更新中，React 回自上而下深度遍历子代 fiber，如果遍历到一个 fiber，那么就会把当前的 fiber 指向 workInProgress
* __current__ 树，在初始化更新中，current = null，在第一次 fiber 调和之后，会将 wordIngProgress 树赋值给 current 树，React 来用 workinPorgress 和 current 来确保一次更新中，快速构建，并且状态不会丢失。
* __Component__  项目中的class组件
* __nextProps__ 组件在一次更新中的props
* __renderExpirationTime__ 作为下一次渲染的过期时间

在组件实例上可以通过 ___reactInternals__ 属性来访问组件对应的 fiber 对象。
在 fiber 对象上，可以通过 stateNode 来访问当前 fiber 对应的组件实例。
[两者关系如图](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/018a9cbd20df478a955b84beba770674~tplv-k3u1fbpfcp-watermark.awebp)

### React 类组件生命周期执行过程探秘

React 中大部分的生命周期都是在 __mountClassInstance__ 和 __updateClassInstance__ 这两个方法中执行

__初始化阶段__

__① constructor 执行__

在 mount 阶段，首先执行的是 constructClassInstacne 函数用来实例化 React 组件，在组件实例化之后会调用 mountClassInstance
> packages/react-reconciler/src/ReactFiberClassComponent.js 

```
function mountClassInstance(workInProgress,ctor,newProps,renderExpirationTime){
    const instance = workInProgress.stateNode;
     const getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  if (typeof getDerivedStateFromProps === 'function') { /* ctor 就是我们写的类组件，获取类组件的静态防范 */
     const partialState = getDerivedStateFromProps(nextProps, prevState); /* 这个时候执行 getDerivedStateFromProps 生命周期 ，得到将合并的state */
     const memoizedState = partialState === null || partialState === undefined ? prevState : Object.assign({}, prevState, partialState); // 合并state
     workInProgress.memoizedState = memoizedState;
     instance.state = workInProgress.memoizedState; /* 将state 赋值给我们实例上，instance.state  就是我们在组件中 this.state获取的state*/
  }
  if(typeof ctor.getDerivedStateFromProps !== 'function' &&   typeof instance.getSnapshotBeforeUpdate !== 'function' && typeof instance.componentWillMount === 'function' ){
      instance.componentWillMount(); /* 当 getDerivedStateFromProps 和 getSnapshotBeforeUpdate 不存在的时候 ，执行 componentWillMount*/
  }
}
```

作用：
* 初始化 state，比如可以截取路由中的参数，赋值给 state
* 对类组件的事件做处理，比如绑定this
* 对类组件进行一些必要生命周期的劫持，渲染劫持

__② getDerivedStateFromProps__

在初始化阶段，getDerivedStateFromProps 是第二个执行的生命周期，他是从 ctor 类上直接绑定的静态方法，传入 props，state。返回值将 state 合并 return，传递给组件实例使用

> getDerivedStateFromProps(nextProps,prevState)

两个参数
* nextProps 父组件新传递的 props
* prevState 组件在此次更新前对 state

getDerivedStateFromPorps 方法作为类的静态属性方法执行，内部访问不到 this，React 对该生命周期的定义为取缔 componentWillMount 和 componentWillReceiveProps
如果把 getDerviedStateFromProps 英文分解 get | Derived | State | From | Props 翻译：从 props 中得到派生的 state，

用法：
```
static getDerivedStateFromProps(newProps){
    const { type } = newProps
    switch(type){
        case 'fruit' : 
        return { list:['苹果','香蕉','葡萄' ] } /* ① 接受 props 变化 ， 返回值将作为新的 state ，用于 渲染 或 传递给s houldComponentUpdate */
        case 'vegetables':
        return { list:['菠菜','西红柿','土豆']}
    }
}
render(){
    return <div>{ this.state.list.map((item)=><li key={item} >{ item  }</li>) }</div>
}
```
getDerivedStateFromPorps 作用：
* 代替 componentWillMount 和 componentWillReceiveProps 
* 组件初始化或者更新时，将 props 映射到 state
* 返回值与 state 合并完，可以作为 shouldComponentUpdate 第二个参数 newState。可以判断是否渲染组件（两者没有必然联系）

__③ componentWillMount 执行__ 

如果存在 getDerivedStateFromPorps 和 getSnapshotBeforeUpdate 就不会执行生命周期 componentWillMount
在 React v6.3 componentWillMount，componentWillReceivePrpps，componentWillUpdate 三个生命周期加上了 UNSAFE_ 标识
* UNSAFE_componentWillMount
* UNSAFE_componentWillReceiveProps
* UNSAFE_componentWillUpdate

__④ render 函数执行__ 

__⑤componentDidMount执行__


